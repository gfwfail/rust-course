# ç¬¬ 35 è¯¾ï¼šå® (Macros) å…¥é—¨

> ğŸ“… 2026-02-17 03:00 (AEDT)

---

## ä¸ºä»€ä¹ˆè¦å­¦å®ï¼Ÿ

ä½ ä»¬å·²ç»ç”¨è¿‡å¾ˆå¤šå®äº†ï¼š

```rust
println!("Hello, {}!", name);  // æ‰“å°å®
vec![1, 2, 3];                  // åˆ›å»ºå‘é‡
#[derive(Debug, Clone)]        // æ´¾ç”Ÿå®
```

æ³¨æ„åˆ°æ²¡ï¼Ÿ**å®è°ƒç”¨åé¢éƒ½æœ‰ `!`**ï¼Œè¿™æ˜¯åŒºåˆ†å®å’Œå‡½æ•°çš„æ ‡å¿—ã€‚

**å®èƒ½åšå‡½æ•°åšä¸åˆ°çš„äº‹ï¼š**
- æ¥å—å¯å˜æ•°é‡çš„å‚æ•°ï¼ˆ`println!` å¯ä»¥ä¼ ä»»æ„ä¸ªå‚æ•°ï¼‰
- åœ¨ç¼–è¯‘æœŸå±•å¼€ä»£ç ï¼ˆé›¶è¿è¡Œæ—¶å¼€é”€ï¼‰
- ç”Ÿæˆé‡å¤çš„æ¨¡å¼ä»£ç ï¼ˆå‡å°‘ boilerplateï¼‰

---

## ä¸¤ç§å®

Rust æœ‰ä¸¤å¤§ç±»å®ï¼š

| ç±»å‹ | è¯­æ³• | ç”¨é€” |
|------|------|------|
| **å£°æ˜å¼å®** | `macro_rules!` | æ¨¡å¼åŒ¹é…æ›¿æ¢ï¼Œåƒé«˜çº§æŸ¥æ‰¾æ›¿æ¢ |
| **è¿‡ç¨‹å®** | `#[derive(...)]` ç­‰ | æ“ä½œ ASTï¼ŒåŠŸèƒ½æ›´å¼ºå¤§ |

ä»Šå¤©å…ˆè®² **å£°æ˜å¼å®**ï¼Œè¿™æ˜¯æœ€å¸¸ç”¨çš„ã€‚

---

## ç¬¬ä¸€ä¸ªå®ï¼šsay_hello!

```rust
macro_rules! say_hello {
    // æ— å‚æ•°ç‰ˆæœ¬
    () => {
        println!("Hello!");
    };
    // å¸¦åå­—ç‰ˆæœ¬
    ($name:expr) => {
        println!("Hello, {}!", $name);
    };
}

fn main() {
    say_hello!();           // Hello!
    say_hello!("Rust");     // Hello, Rust!
}
```

**è§£è¯»ï¼š**
- `macro_rules!` å®šä¹‰å£°æ˜å¼å®
- `() => { ... }` æ˜¯ä¸€æ¡åŒ¹é…è§„åˆ™
- `$name:expr` æ•è·ä¸€ä¸ªè¡¨è¾¾å¼ï¼Œç»‘å®šåˆ° `$name`

---

## æ•è·ç±»å‹ (Fragment Specifiers)

`$xxx:type` ä¸­çš„ type å¯ä»¥æ˜¯ï¼š

| ç±»å‹ | åŒ¹é…ä»€ä¹ˆ | ç¤ºä¾‹ |
|------|----------|------|
| `expr` | è¡¨è¾¾å¼ | `1 + 2`, `foo()` |
| `ident` | æ ‡è¯†ç¬¦ | `x`, `my_func` |
| `ty` | ç±»å‹ | `i32`, `Vec<T>` |
| `pat` | æ¨¡å¼ | `Some(x)`, `_` |
| `stmt` | è¯­å¥ | `let x = 1;` |
| `block` | ä»£ç å— | `{ ... }` |
| `literal` | å­—é¢é‡ | `42`, `"hello"` |
| `tt` | token tree | ä»»æ„ token |

---

## é‡å¤æ¨¡å¼ï¼šå¤„ç†å¯å˜å‚æ•°

è¿™æ˜¯å®æœ€å¼ºå¤§çš„åŠŸèƒ½ï¼

```rust
macro_rules! vec_of_strings {
    // $(...),* è¡¨ç¤ºé‡å¤åŒ¹é…ï¼Œç”¨é€—å·åˆ†éš”
    ( $( $x:expr ),* ) => {
        {
            let mut v = Vec::new();
            $(
                v.push($x.to_string());
            )*
            v
        }
    };
}

fn main() {
    let v = vec_of_strings!["a", "b", "c"];
    // å±•å¼€ä¸ºï¼š
    // let mut v = Vec::new();
    // v.push("a".to_string());
    // v.push("b".to_string());
    // v.push("c".to_string());
    // v
    
    println!("{:?}", v);  // ["a", "b", "c"]
}
```

**é‡å¤è¯­æ³•ï¼š**
- `$( ... ),*` â€” é›¶æ¬¡æˆ–å¤šæ¬¡ï¼Œé€—å·åˆ†éš”
- `$( ... ),+` â€” ä¸€æ¬¡æˆ–å¤šæ¬¡ï¼Œé€—å·åˆ†éš”
- `$( ... );*` â€” ç”¨åˆ†å·åˆ†éš”

---

## å®æˆ˜ï¼šç®€åŒ– HashMap åˆ›å»º

åˆ›å»º HashMap å¤ªå•°å—¦äº†ï¼š

```rust
let mut map = HashMap::new();
map.insert("a", 1);
map.insert("b", 2);
// çƒ¦æ­»äº†...
```

å†™ä¸ªå®ï¼

```rust
macro_rules! hashmap {
    ( $( $key:expr => $value:expr ),* $(,)? ) => {
        {
            let mut map = std::collections::HashMap::new();
            $(
                map.insert($key, $value);
            )*
            map
        }
    };
}

fn main() {
    let scores = hashmap! {
        "Alice" => 100,
        "Bob" => 85,
        "Carol" => 92,  // æœ«å°¾é€—å·ä¹Ÿæ”¯æŒ
    };
    
    println!("{:?}", scores);
}
```

**æ³¨æ„ï¼š** `$(,)?` è¡¨ç¤ºå¯é€‰çš„æœ«å°¾é€—å·ã€‚

---

## é€’å½’å®ï¼šæ›´å¤æ‚çš„æ¨¡å¼

å®å¯ä»¥è°ƒç”¨è‡ªå·±ï¼

```rust
macro_rules! count {
    // åŸºç¡€æƒ…å†µï¼šç©º
    () => { 0 };
    // é€’å½’ï¼šåƒæ‰ä¸€ä¸ªï¼Œæ•°é‡ +1
    ($head:tt $($tail:tt)*) => {
        1 + count!($($tail)*)
    };
}

fn main() {
    let n = count!(a b c d e);
    println!("Count: {}", n);  // Count: 5
}
```

---

## å®çš„å‘

### 1. å«ç”Ÿæ€§ (Hygiene)

å®å†…éƒ¨çš„å˜é‡ä¸ä¼šæ±¡æŸ“å¤–éƒ¨ï¼š

```rust
macro_rules! make_x {
    () => {
        let x = 42;  // è¿™ä¸ª x æ˜¯å®å†…éƒ¨çš„
    };
}

fn main() {
    let x = 1;
    make_x!();
    println!("{}", x);  // è¿˜æ˜¯ 1ï¼Œä¸æ˜¯ 42
}
```

### 2. è°ƒè¯•å›°éš¾

å®å±•å¼€åçš„é”™è¯¯ä¿¡æ¯å¾ˆè¿·æƒ‘ã€‚ç”¨ `cargo expand` æŸ¥çœ‹å±•å¼€ç»“æœï¼š

```bash
cargo install cargo-expand
cargo expand  # æŸ¥çœ‹æ‰€æœ‰å®å±•å¼€
```

### 3. åŒ¹é…é¡ºåº

è§„åˆ™ä»ä¸Šåˆ°ä¸‹åŒ¹é…ï¼Œå†™å¯¹é¡ºåºï¼

---

## æ ‡å‡†åº“å¸¸ç”¨å®

| å® | ç”¨é€” |
|----|------|
| `println!` / `print!` | æ‰“å°åˆ°æ ‡å‡†è¾“å‡º |
| `format!` | æ ¼å¼åŒ–å­—ç¬¦ä¸² |
| `vec!` | åˆ›å»º Vec |
| `panic!` | è§¦å‘ panic |
| `assert!` / `assert_eq!` | æ–­è¨€ |
| `dbg!` | è°ƒè¯•æ‰“å°ï¼ˆå¸¦æ–‡ä»¶è¡Œå·ï¼‰ |
| `todo!` / `unimplemented!` | å ä½ç¬¦ |
| `cfg!` | ç¼–è¯‘æ—¶æ¡ä»¶æ£€æŸ¥ |

---

## è¯¾åä½œä¸š

å†™ä¸€ä¸ª `log!` å®ï¼Œæ”¯æŒï¼š

```rust
log!(INFO, "Server started");
log!(ERROR, "Failed: {}", reason);
```

è¾“å‡ºæ ¼å¼ï¼š`[INFO] Server started`

æç¤ºï¼šåŒ¹é… `$level:ident` å’Œ `$($arg:tt)*`

---

## å‚è€ƒç­”æ¡ˆ

```rust
macro_rules! log {
    ($level:ident, $($arg:tt)*) => {
        println!("[{}] {}", stringify!($level), format!($($arg)*));
    };
}

fn main() {
    log!(INFO, "Server started on port {}", 8080);
    log!(ERROR, "Connection failed");
    log!(DEBUG, "x = {}, y = {}", 10, 20);
}
```

`stringify!` å®æŠŠæ ‡è¯†ç¬¦è½¬æˆå­—ç¬¦ä¸²å­—é¢é‡ã€‚

---

## ä¸‹èŠ‚é¢„å‘Š

ä¸‹èŠ‚è¯¾è®² **è¿‡ç¨‹å® (Procedural Macros)**ï¼š
- è‡ªå®šä¹‰ `#[derive(...)]`
- å±æ€§å® `#[route("/api")]`
- å‡½æ•°å¼è¿‡ç¨‹å®

---

*ç¬”è®°æ•´ç†ï¼šæ€§å¥´001*
