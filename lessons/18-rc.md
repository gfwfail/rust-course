# 第18课：Rc 引用计数

**多个所有者** 共享同一数据？用 `Rc`（Reference Counting）！

## 基本用法

```rust
use std::rc::Rc;

fn main() {
    let data = Rc::new(String::from("hello"));
    
    let a = Rc::clone(&data);  // 引用计数 +1
    let b = Rc::clone(&data);  // 引用计数 +1
    
    println!("引用计数: {}", Rc::strong_count(&data));  // 3
    
    drop(b);  // 引用计数 -1
    println!("引用计数: {}", Rc::strong_count(&data));  // 2
}
// 全部离开作用域，计数归零，数据释放
```

## Rc::clone vs .clone()

```rust
// ✅ 推荐：明确表示只是增加引用计数
let a = Rc::clone(&data);

// ⚠️ 也行，但可能误以为是深拷贝
let a = data.clone();
```

`Rc::clone` 只增加计数，不复制数据，开销很小。

## Rc 的限制

- **只能用于单线程**（多线程用 `Arc`）
- **只能读，不能改**（内部是不可变的）
- 会造成**循环引用**导致内存泄漏

## 实际场景：共享数据

```rust
use std::rc::Rc;

struct Node {
    value: i32,
    next: Option<Rc<Node>>,
}

fn main() {
    let shared = Rc::new(Node { value: 1, next: None });
    
    let a = Node { value: 2, next: Some(Rc::clone(&shared)) };
    let b = Node { value: 3, next: Some(Rc::clone(&shared)) };
    
    // a 和 b 都指向 shared
}
```

---

**下节课**：RefCell 内部可变性
